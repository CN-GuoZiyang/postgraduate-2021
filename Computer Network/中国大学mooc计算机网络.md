## 第一章 计算机网络概述

### 1.1 计算机网络基本概念

#### 1.1.1 基础概念

计算机网络=通信技术+计算机技术

计算机网络是通信技术与计算机技术紧密结合的产物

通信系统模型：信源，发送设备，信道，噪声源，接收设备，信宿

计算机网络就是一种特殊的通信网络

计算机网络是互联的、自治的计算机集合

自治：无主从关系

互连：互连互通，通过通信链路

在距离较远的情况下，通过交换网络互连主机

交换网络中的重要节点被称为交换节点，通常使用路由器或交换机

Internet的两个角度解释：

- 组成细节的角度：全球最大的互连网络，ISP，网络互连，Internet是数以百万计的互连的==计算设备==的集合，主机=端系统，这些设备通过==通信链路==（光线、无线电）连接，并通过==分组交换==设备（路由器和交换机）转发分组数据包
- 服务角度：为网络应用提供通信服务的通信基础设施，为网络应用提供应用编程接口（API）

仅有硬件连接无法保证Internet，还需要==协议==

协议是计算机网络有序运行的重要保证

硬件是计算机网络的基础，然而，计算机网络中的数据交换必须遵守事先约定好的规则

任何通信或信息交换过程都需要遵循规则

网络通信：通信主体是机器，交换电子化或数字化信息

#### 1.1.2 协议

定义：网络协议简称协议，是为进行网络中的数据交换而建立的规则、标准或约定

协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到消息或发生的事件所采取的动作

协议的三要素：

- 语法（Syntax），数据与控制信息的结构或格式
- 语义（Semantics），需要发出何种控制信息，完成何种动作以及作出的相应，差错控制
- 时序（Timing）：事件顺序，速度匹配

协议规范了网络中所有信息发送和接收过程，是学习网络的重要内容之一，是网络创新的表现形式之一

### 1.2 计算机网络结构

#### 1.2.1 基础结构

- 网络边缘：主机，网络应用
- 接入网络，物理介质：有限或无限通信链路
- 网络核心（核心网络）：互连的路由器或分组转发设备，网络之网络

主机（端系统）：

位于网络边缘处，运行各种网络应用程序

**客户/服务器（C/S）应用模型**：客户发送请求，接收服务器响应，例如Web应用，FTP应用

**对等（P2P）应用模型**：无（或不依赖）专用服务器，通信在对等的实体之间直接进行，例如Gnutella，BT，Skype等

接入网络：

将网络边缘接入核心网（边缘路由器）

分为：住宅（家庭）接入网络，机构接入网络，移动接入网络

重要概念：

- 带宽（bandwidth）：bps
- 共享/独占

机构企业接入网络通常使用以太网

无线接入网络：通过共享等无线接入网络连接端系统与路由器，通过基站或称为接入点，分为两种：无线局域网和广域无线接入（蜂窝网）

网络核心：

互连的路由网络，关键功能：路由+转发

路由（routing）：确定分组从源到目的传输路径

转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口

网络核心解决的基本问题：实现数据从源主机通过网络核心送达目的主机：数据交换技术

#### 1.2.2 Internet结构

Internet网络：网络之网络

端系统通过**接入ISP**连接到Internet

接入ISP必须进一步连接，这样才能保证任意两个主机才可以互相发送分组

一级商业ISP：提供国家或国际范围的网络覆盖，如联通、电信、Sprint、AT&T

内容提供商网络：私有网络，连接其数据中心与Internet，通常绕过一级ISP和区域ISP

### 1.3 网络核心

#### 1.3.1 电路交换

数据交换：实现数据通过网络核心从源主机到达目的主机

交换设备：

- 动态转接
- 动态分配传输资源

数据交换的类型：

- 电路交换
- 报文交换
- 分组交换

最典型的电路交换网络：电话网络

电路交换的三个阶段：

1. 建立连接（呼叫/电路建立）
2. 通信
3. 释放连接（拆除电路）

电路交换可独占资源，无法被第三方共享

电路交换在物理层面可通过多路复用技术共享物理线路

#### 1.3.2 多路复用

多路复用，简称复用，是通信技术的基本概念

将链路/网络资源（如带宽）划分为资源片，将资源片分配给各路呼叫（calls），每路呼叫独占分配到的资源片进行通信

资源片可能闲置

典型方法：频分多路复用（FDM），时分多路复用（TDM），波分多路复用（WDM），码分多路复用（CDM）

频分多路复用：按照频率划分，互不干扰

频分多路复用的各用户占用不同的带宽资源（Hz），用户在被分配到某个频带后，都始终占用这个频带

时分多路复用：将时间划分为一段段等长的时分复用帧，每个用户在每个帧中占用固定需要的时隙，每个用户所占用的时隙时周期性出现的，周期就是帧的长度

波分多路复用：

波分复用就是光的频分复用

码分复用技术：

广泛应用于无线链路共享（蜂窝，卫星）

每个用户分配一个唯一的m bit的码片序列，其中0用-1表示，1用+1表示

各个用户使用相同频率的载波，利用各自码片序列编码数据

编码信号=原始数据*码片序列

各用户的码片序列相互正交，意味着

![](http://ww4.sinaimg.cn/large/006tNc79gy1g5za5emknzj30aw027jro.jpg)

即可保证互不干扰，解码原理

![](http://ww3.sinaimg.cn/large/006tNc79gy1g5za8awv1ej30d306mmyo.jpg)

#### 1.3.3 报文交换

报文：源（应用）发送信息整体，作为一个整体，如一个文件

#### 1.3.4 分组交换

分组：报文拆分出来的一系列相对较小大数据包，并在每个数据包前加一个头部信息，构成一个分组

分组交换需要报文的拆分与重组，可能产生额外开销（时间，空间）

分组交换的多路复用顺序不确定，数据包到达即可占用链路，这种链路共享称为统计多路复用（按需共享）

路由器暂存分组后发送到目的地，称为存储-转发（store-and-forward）

报文交换与分组交换都使用存储-转发交换方式

#### 1.3.5 报文交换与分组交换

分组交换：传输延迟

将报文拆分成较小长度为L bits的分组，在传输速率为R的链路上传输分组，延迟为
$$
\frac{L(bits)}{R(bits/sec)}
$$
报文交换：报文长度为M bits，链路带宽为R bps，每次传输报文需要M/R秒

通常，报文交换速度较快，但由于分组交换可以并行地转发分组，于是实际速度较快，且对路由器缓存能力要求较低，于是分组交换较为通用

结论：

报文M bits，链路带宽R bps，分组长度L bits，跳步数h，路由器数n（n=h-1），交付时间为
$$
T=\frac{M}{R}+\frac{(h-1)L}{R}=\frac{M}{R}+\frac{nL}{R}
$$
分组交换更加适用于突发数据传输网络，可以重复共享资源，简单，无需呼叫建立，但是可能产生拥塞，导致分组延迟或丢失，需要协议处理可靠数据传输和拥塞控制

### 1.4 计算机网络性能

#### 1.4.1 速率、带宽、延迟

速率即数据率或称为数据传输速率或比特率，最重要的性能指标

单位时间（s）传输信息（bit）量

单位b/s，或bps，kb/s，Mb/s，Gb/s

速率往往是指额定速率或者标称速率

带宽指数字信道所能传送的最高数据率，单位b/s（bps）

延迟/时延，路由器中的数据包可能会产生排队，导致延迟，路由器缓存满会导致丢包

$d_{proc}$：节点处理延迟（差错检测，输出链路的确定），通常较小，不超过ms

$d_{queue}$：排队延迟，等待输出链路可用，取决于路由器的拥塞程度

$d_{trans}$：传输延迟，传输一个分组需要的时间，取决于分组长度L，链路带宽R，$d_{trans}=L/R$

$d_{prop}$：传播延迟，数据包在链路上传输的时间，与物理链路长度d有关，也与信号传输速度s有关，铜缆传输速率通常为0.7c，约为$2\times 10^8m/s$

排队延迟：假设链路带宽R bps，分组长度L bps，平均分组到达速率a

流量强度=La/R

若接近0，表明平均排队延迟很小，接近1表明很大，超过1表示超出服务能力，平均排队延迟无限大

#### 1.4.2 时延带宽积、丢包率、吞吐量

时延带宽积=传播时延*带宽

在一秒内发送的比特数目

![](http://ww3.sinaimg.cn/large/006y8mN6gy1g67jarf9pfj30hk060dhv.jpg)

链路的时延带宽积又称为以比特为单位的链路长度

分组丢失（丢包）：

- 队列缓存容量有限
- 分组到达已满队列将被丢弃
- 丢弃分组可能由前序结点或源重发（也可能不重发）

吞吐量（吞吐率）：表示在发送端到接收端之间传送数据速率

- 即时吞吐量：给定时刻到速率
- 平均吞吐量：一段时间的平均速率

瓶颈链路：端到端路径上，限制端到端吞吐量的链路，通常是带宽最小的链路

### 1.5 计算机网络体系结构

#### 1.5.1 计算机网络体系结构概述

描述网络结构的有效方式：分层结构

计算机网络的体系结构是从功能上描述，是一种分层结构，每层遵循某个/某些网络协议完成本层的功能

计算机网络体系结构是计算机网络的各层及其协议的集合（抽象）

优点：结构清晰，模块化思想，有利于标准化

![](http://ww3.sinaimg.cn/large/006y8mN6gy1g67ky7ozz4j30ir05y413.jpg)

实体表示任何可发送或接收信息的硬件或软件进程，协议是控制两个==对等实体==进行通信的规则集合，协议是“水平的”

任一层实体需要使用下层的服务，遵循本层协议，实现本层的功能，向上层提供服务，服务是垂直的，上层的实现对上层是透明的（无法感知）

同系统的相邻实体间通过接口进行交互，通过服务访问点（SAP），交换原语，指定请求的特定服务

#### 1.5.2 OSI参考模型

OSI：开放系统互连模型，目的是支持异构网络系统的互联互通，理论成功，市场失败

将网络从功能上划分为七层，从下往上依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

![](https://ws4.sinaimg.cn/large/006Xmmmgly1g68gh6r9q6j30gj0bfae8.jpg)

主机完成七层，中间系统完成低三层，上四层从协议角度说直接从源主机对应到目标主机，上四层称为端到端层

应用层到网络层逐步加头，数据链路层还会加上尾部信息后传给物理层

数据封装原因：增加控制信息，以构造协议数据单元（PDU），控制信息包括：

- 地址：标识发送端和接收段
- 差错检测编码：用于差错检测或纠正
- 协议控制：实现协议功能的附加信息，如优先级、服务质量和安全控制等（不必要）

物理层功能：传输每个比特

- 接口特性：机械特性、电气特性、功能特性、规程（过程）特性
- 比特编码
- 数据率（传输速率）
- 比特同步：时钟同步
- 传输模式：单工（单向），半双工（交替）、全双工

数据链路层功能：

- 负责结点-结点等数据传输，物理链路直接相连的相邻结点之间的传输，传输单位为帧
- 组帧，加头加尾，方便目标成功切分数据帧
- 物理寻址，在帧头中增加发送端或接收端的物理地址标识
- 流量控制，避免淹没接收端
- 差错控制，检测并重传损坏或丢失帧，避免重复帧
- 访问（接入）控制，决定哪个设备拥有链路（物理介质）控制使用权

网络层功能：

- 负责源主机到目的主机数据分组的交互，可能穿越多个网络
- 逻辑寻址：全局唯一的逻辑地址，确保数据分组被送达目的主机
- 路由：路径选择
- 分组转发

传输层功能：

- 负责源-目的（端到端，进程间）的完整报文传输
- 报文的分段与重组
- SAP寻址
- 连接（逻辑）控制
- 流量控制

回话层功能：

- 对话控制：对话的建立与维护
- 同步：在数据流中插入同步控制点
- 是最薄的一层

表示层功能：

- 处理两个系统之间交换信息的语法和语义问题
- 数据表示转化，转换为主机独立的编码
- 加密和解密
- 压缩和解压缩

应用层功能：

- 支持用户通过用户代理（浏览器）或网络接口使用网络（服务）
- 典型的应用层服务：FTP、SMTP、HTTP

#### 1.5.3 TCP/IP参考模型

![](http://ww3.sinaimg.cn/large/006y8mN6gy1g68sn5aljhj30gs099q5n.jpg)

#### 1.5.4 五层参考模型

应用层、传输层、网络层、数据链路层、物理层

综合了OSI和TCP/IP的优点

1. 应用层：支持各种网络应用，FTP、SMTP、HTTP
2. 传输层：进程-进程的数据传输，TPC、UDP
3. 网络层：源主机到目标主机的数据分组路由与转发，IP协议、路由协议等
4. 链路层：相邻网络元素的数据传输，以太网、802.11、PPP
5. 物理层：比特传输

![](http://ww3.sinaimg.cn/large/006y8mN6gy1g68tuoof4aj30iv0bdjuu.jpg)

交换机两层，路由器三层

每一层封装完成后的数据：链路层数据帧，网络层数据报，传输层数据端，应用层报文

### 1.6 作业1

1.

如图所示网络。A在t=0时刻开始向C发送一个2Mbits的文件；B在t=0.1+e秒（e为无限趋近于0的小正实数）向D发送一个1Mbits的文件。忽略传播延迟和结点处理延迟。

![img](https://nos.netease.com/edu-image/EE40146789C7C731A037B8EC75EB9592-1443088488575?imageView&thumbnail=520x520&quality=100)

请回答下列问题：

1) 如果图中网络采用存储-转发方式的报文交换，则A将2Mbits的文件交付给C需要多长时间？B将1Mbits的文件交付给D需要多长时间？

答：将图中两个转发节点设为节点1和节点2，且缓存都大于2Mbits。A将文件以报文的形式发送到节点1需要时间2Mb / 10Mb/s = 0.2s，从节点1发送到节点2需要2Mb / 20Mb/s = 0.1s，从节点2发送到C需要2Mb / 10Mb/s = 0.2s，于是A需要0.5s将文件交付给C。

B将文件发送到节点1需要1Mb / 10Mb/s = 0.1s，此时时间为0.2+e秒，A发送的文件正在从节点1传输到节点2，B的文件等待至0.3s时（即等待0.1-e秒）开始从节点1发送到节点2，需要时间1Mb / 20Mb/s = 0.05s，B的文件从节点2传送到D需要1Mb / 10Mb/s = 0.1s，于是B需要0.35-e秒将文件交付给D。

2) 如果图中网络采用存储-转发方式的分组交换，分组长度为等长的1kbits，且忽略分组头开销以及报文的拆装开销，则A将2Mbits的文件交付给C需要大约多长时间？B将1Mbits的文件交付给D需要大约多长时间？

答：在0s到1s间，A发送了1000个分组，一共用时1000*(1000b / 10Mb/s) = 0.1s，从0.1s开始，A发送的文件和B发送的文件共享节点链路，A还需要花费1Mb / 10Mb/s + 2 * (1000b / 10Mb/s) = 0.1002s交付剩余1000分组，于是A需要0.2002s交付文件。

B向D交付文件共需要1Mb / 10Mb/s + 2 * (1000b / 10Mb/s) = 0.1002s

3) 报文交换与分组交换相比，哪种交换方式更公平？（即传输数据量小用时少，传输数据量大用时长）

分组交换更公平

2.

考虑两台主机A和主机B由一条带宽为R bps、长度为M米的链路互连，信号传播速率为V m/s。假设主机A从t=0时刻开始向主机B发送分组，分组长度为L比特。试求：

1) 传播延迟（时延）dp；

答：dp = M / V

2) 传输延迟dt；

答：dt = L / R

3) 若忽略结点处理延迟和排队延迟，则端到端延迟de是多少？

答：de = dt + dp = L / R + M / V

4) 若dp>dt，则t=dt时刻，分组的第一个比特在哪里？

答：分组的第一个比特位于距离主机A的V*dt米的链路上

5) 若V=250000km/s，L=512比特，R=100 Mbps，则使带宽时延积刚好为一个分组长度（即512比特）的链路长度M是多少？

**(注：1k=10^3,1M=10^6)**

答：带宽时延积 = R * dp = R* M / V = 512，所以M = 1280米

3.

假设主机A向主机B以存储-转发的分组交换方式发送一个大文件。主机A到达主机B的路径上有3段链路，其速率分别是R1=500kbps，R2=2Mbps，R3=1Mbps。试求：

1) 假设网络没有其他流量，则传送该文件的吞吐量是多少？

答：R = min{R1+R2+R3} = min{500kbps, 2Mbps, 1Mbps} = 500kbps

2) 假设文件大小为4MB，则传输该文件到主机B大约需要多少时间？

**(注：1k=10^3,1M=10^6)**

T = 4MB / R = 4 * 10^3 / 500kbps = 64s

## 第二章 网络应用

### 2.1 网络应用的基本原理

#### 2.1.1 网络应用体系结构

- 客户机/服务器结构（Client-Server，C/S）
- 点对点结构（Peer-to-peer，P2P）
- 混合结构（Hybrid）

客户机/服务器结构：

- 服务器
  - 7*24小时提供服务
  - 永久性访问地址/域名
  - 利用大量服务器实现可扩展性
- 客户机
  - 与服务器通信，利用服务器提供的服务
  - 间歇性接入网络
  - 可能使用动态IP地址
  - 不会与其他客户机直接通信

例子：Web应用

纯P2P结构：

- 没有永久在线的服务器
- 任意端系统/节点可以直接通信
- 节点间歇性接入网络
- 节点可能改变IP地址
- 优点：高度可伸缩，缺点：难于管理

混合结构：

例如Napster：文件传输使用P2P，文件搜索采用C/S

#### 2.1.2 网络应用进程通信

网络应用的基础：进程间通信

不同主机上运行的进程间通信：通过消息交换

客户机进程：发起通信的进程

服务器进程：等待通信请求的进程

P2P架构的应用中也有客户机和服务器进程

进程间通信利用socket发送/接收消息实现

传输基础设施向进程提供API：传输协议的选择和参数的设置

进程的寻址：

不同主机上的进程间通信，则每个进程必须有标识符

寻址主机：IP地址

每个通信的进程都会被分配给一个端口号

进程的标识符：IP地址+端口号

应用层协议：

- 网络应用需要遵循应用层协议
- 公开协议：由RFC（Request For Comments）定义，允许互操作，如HTTP、SMTP
- 私有协议：如P2P文件共享应用

应用层协议的内容：

- 消息的类型（type）：请求消息，响应消息
- 消息的语法（syntax）格式：有哪些字段，字段的描述
- 字段的语义（semantics）：字段信息的含义
- 规则（rules）：进程何时发送/响应消息

#### 2.1.3 网络应用要求

网络应用的需求：

- 数据丢失/可靠性
- 时间/延迟
- 带宽

Internet提供的传输服务：

- TCP服务
  - 面向连接：客户机/服务器进程间需要建立连接
  - 可靠的传输
  - 流量控制：发送方不会发送速度过快，超过接收方的处理能力
  - 拥塞控制：当网络负载过重时能够限制发送方的发送速度
  - 不提供时间/延迟保障
  - 不提供最小带宽保障
- UDP服务
  - 无连接
  - 不可靠的数据传输
  - 不提供：
    - 可靠性保障
    - 流量控制
    - 拥塞控制
    - 延迟保障
    - 带宽保障

|   应用   |        应用层协议         | 传输层协议 |
| :------: | :-----------------------: | :--------: |
|  email   |     SMTP【RFC 2821】      |    TCP     |
| 远程终端 |     Telnet【RFC 854】     |    TCP     |
|   Web    |     HTTP【RFC 2616】      |    TCP     |
| 文件传输 |      FTP【RFC 959】       |    TCP     |
| 多媒体流 |  多种（如RealNetworks）   |  TCP或UDP  |
| 网络电话 | 多种（如Vonage、Dialpad） |  通常UDP   |

### 2.2 Web应用

#### 2.2.1 Web应用概述

- World Wide Web：Tim Berners-Lee
  - 网页
  - 网页互相链接
- 网页包含多个对象：
  - 对象：HTML文件、JPEG图片、视频文件、动态脚本等
  - 基本HTML文件：包含对其它对象引用的链接
- 对象的寻址
  - URL：统一资源定位器，RFC1738
  - Scheme://host:port/path

HTTP协议概述：

超文本传输结构，C/S结构

- 客户——Browser：请求、接收、展示Web对象
- 服务器——Web Server：响应客户的请求，发送对象

HTTP有多个版本，都使用TCP传输服务

- 服务器在80端口等待客户端请求
- 浏览器发起到服务器的TCP连接（创建Socket）
- 服务器接受来自浏览器的TCP连接
- 浏览器与Web服务器交换HTTP消息
- 关闭TCP连接

无状态：服务器不维护任何有关客户端过去所发请求的信息

#### 2.2.2 HTTP连接类型

两种连接类型：

- 非持久性连接，每个TCP连接最多允许传输一个对象，HTTP 1.0版本使用非持久性连接
- 持久性连接，每个TCP连接允许传输多个对象，HTTP 1.1版本默认使用持久性连接

非持久性连接工作过程（以连接访问www.someSchool.edu/someDepartment/home.index 为例，假设包含文本和指向10个jpeg图片的链接）：

1. HTTP客户端向地址为www.someSchool.edu 的服务器上的HTTP服务器进程（端口80）发起TCP连接请求
2. HTTP服务器在端口80等待TCP连接请求，接受连接并通知客户端
3. HTTP客户端将HTTP请求消息（包含URL地址）通过TCP连接的套接字发出，消息中所包含的URL表明客户端需要对象someDepartment/home.index
4. HTTP服务器收到请求消息，解析，产生包含所需要对象的响应消息，并通过套接字发给客户端
5. HTTP服务器关闭TCP连接
6. HTTP客户端收到响应消息，解析HTML文件，显示HTML文件，发现10个指向jpeg对象的超链接
7. 客户端为每个jpeg对象重复以上步骤

响应时间分析与建模：

RTT（Round Trip Time）：从客户端发送一个很小的数据包到服务器并返回所经历的时间

响应时间：

- 发起、建立TCP连接：1个RTT
- 发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT
- 响应消息中所含的文件/对象传输时间
- Total = 2RTT + 文件发送时间

非持久性连接的问题：每个对象都需要两个RTT，操作系统需要为每个TCP连接开销资源

持久性连接：

- 发送响应之后，服务器保持TCP连接的打开
- 后续的HTTP消息可以通过这个连接发送

持久性连接分为两种：

- 无流水（pipelining）的持久性连接：客户端只有收到前一个响应后才发送新的请求，每个被引用的对象耗时1个RTT
- 带流水机制的持久性连接：HTTP 1.1默认选项，客户端只要遇到一个引用对象就会尽快发出请求，理想情况下收到所有的引用对象只需要耗时1个RTT

#### 2.2.3 HTTP消息格式

HTTP协议有两类消息：请求消息和响应消息

请求消息：ASCII，可读

```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
User-agent: Mozilla/4.0
Connection: close
Accept-language: fr

```

第一行为请求行，其余为头部行，最下方有一个空行，表示消息结束

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g6c89f15sij30ir0ag0vq.jpg)

方法的类型：

- HTTP/1.0：GET、POST、HEAD（请Server不要将所请求的对象放入相应消息，用于测试）
- HTTP/1.1：GET、POST、HEAD、PUT（将消息体中的文件上传到URL字段所指定的路径）、DELETE（删除URL字段所指定的文件）

响应消息：ASCII码

```http
HTTP/1.1 200 OK
Connection: close
Date: Thu, 06 Aug 1998 12:00:15 GMT
Server: Apache/1.3.0 (Unix)
Last-Modified: Mo, 22 Jun 1998 ...
Content-Length: 6821
Content-Type: text/html

data data data data data ...
```

HTTP响应状态码：响应消息的第一行

如：

- 200 OK
- 301 Moved Permanently
- 400 Bad Request
- 404 Not Found
- 505 HTTP Version Not Supported

#### 2.2.4 Cookie技术

某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通常经过加密），RFC6265

Cookie的组件：

- HTTP响应消息的cookie头部行
- HTTP请求消息的cookie头部行
- 保存在客户端主机上的cookie文件，由浏览器管理
- Web服务器端的后台数据库

Cookie可用于：身份认证、购物车、推荐、Web e-mail

#### 2.2.5 Web缓存/代理服务器技术

功能：在不访问服务器的前提下满足客户端的HTTP请求

缩短客户请求的响应时间、减少机构/组织流量、在大范围内（Internet）实现有效的内容分发（CDN）

1. 用户设定浏览器通过缓存进行Web访问
2. 浏览器向缓存/代理服务器发送所有的HTTP请求
    - 如果所请求对象在缓存中，缓存返回对象
    - 否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象

缓存既充当客户端，也充当服务器，一般由ISP架设

条件性GET方法：确定最新缓存版本

在HTTP请求消息中声明所持有版本的日期，HTTP请求头：If-modified-since: \<date>

在服务器中，如果缓存对象是最新的，则响应消息中不包含对象，HTTP/1.0 304 Not Modified

### 2.3 Email应用

#### 2.3.1 Email应用概述

组成：邮件客户端、邮件服务器（核心）、SMTP协议（Simple Mail Transfer Protocol）

邮件服务器（Mail Server）

- 邮箱：存储发送给该用户的Email
- 消息队列：存储等待发送的Email

SMTP协议（RFC2821）：邮件服务器之间传递消息所使用的协议

使用TCP，端口25

三个阶段：

- 握手
- 消息的传输
- 关闭

命令/响应交互模式：

- 命令：ASCII文本
- 响应：状态代码和语句

Email消息只能包含7位ASCII码

SMTP交互：

```
S: 220 hamburger.edu
C: HELO crepes.fr
S: 250 Hello crepes.fr, pleased to meet you
C: MAIL FROM: <alice@crepes.fr>
S: 250 alice@crepes.fr ... Sender ok
C: RCPT TO: <bob@hamburger.edu>
S: 250 bob@hamburger.edu ... Recipient ok
C: DATA
S: 354 Enter mail, end with "." on a line by itself
C: Do you like ketchup?
C: How about pickles?
C: .
S: 250 Message accepted for delivery
C: QUIT
S: 221 hamburger.edu closing connection
```

SMTP特点：

- 使用持久性连接
- 要求消息必须由7位ASCII码构成
- SMTP服务器使用CRLF.CRLF确定消息结束

与HTTP对比：

- HTTP：拉式（pull）
- SMTP：推式（push）
- 都使用命令/响应交互模式
- 命令和状态代码都是ASCII码
- HTTP：每个对象封装在独立的响应消息中
- SMTP：多个对象在由多个部分构成的消息中发送

#### 2.3.2 Email消息格式与POP3协议

RFC 822：文本消息格式标准

- 头部行（header）
    - To
    - From
    - Subject
- 消息体（body）
    - 消息本身
    - 只能是ASCII字符

MIME：多媒体邮件扩展 RFC 2045，2056，在邮件头部增加额外的行以声明MIME的内容类型

邮件访问协议：从服务器获取邮件

POP：Post Office Protocol（RFC 1939），认证/授权和下载

IMAP：Internet Mail Access Protocol（RFC 1730），更多功能，更加复杂，能操纵服务器上存储的消息

HTTP：163、QQ Mail等

POP：

认证过程：

- User：声明用户名
- Pass：声明密码

事务阶段：

- List：列出消息数量
- Retr：用编号获取消息
- Dele：删除消息
- Quit

POP协议模式：“下载并删除”模式，“下载并保持”模式

POP3是无状态协议

IMAP协议：

- 所有消息统一保存在一个地方：服务器
- 允许用户利用文件夹组织消息
- IMAP支持跨会话的用户状态：
    - 文件夹名字
    - 文件夹与消息ID之间的映射等

### 2.4 DNS应用

#### 2.4.1 DNS概述

Internet上主机/路由器的识别问题

域名与IP地址的映射问题

多层命名服务器构成的分布式数据库，是应用层协议，完成名字的解析

DNS服务：

- 域名向IP地址的翻译
- 主机别名
- 邮件服务器别名
- 负载均衡：Web服务器

查询方式分两种：迭代查询和递归查询

只要域名解析服务器获得域名-IP映射，即缓存这一映射，一段时间后缓存条目失效

本地域名服务器一般会缓存顶级域名服务器的映射，因此根域名服务器不经常被访问

#### 2.4.2 DNS记录和消息格式

DNS记录：资源记录（RR）

格式：name，value，type，ttl

- Type=A，Name为主机域名，Value为IP地址
- Type=NS，Name为域，Value为该域权威域名解析服务器的主机域名
- Type=CNAME，Name为真实域名的别名，Value为真实域名
- Type=MX，Value是与Name相对应的邮件服务器

DNS协议：

- 查询回复式
- 消息格式相同

消息格式：

- 消息头
    - Identification：16位查询编号，回复使用相同的编号
    - flags：
        - 查询或回复
        - 期望递归
        - 递归可用
        - 权威回答

### 2.5 P2P应用

#### 2.5.1 原理与文件分发

文件分发应用：C/S  vs. P2P

从一个服务器向N各节点分发文件所需的时间

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6u7p1afznj30l50cw42f.jpg)

文件大小F，服务器上传带宽$u_s$，节点i的上传带宽$u_i$，节点i的下载带宽$d_i$

C/S架构：

服务器串行地发送N个副本：$NF/u_s$

客户机i需要$F/d_i$时间下载

P2P架构：

服务器发送一个副本：$F/u_s$

客户机i需要$F/d_i$时间下载

总共需要下载NF比特

最快的可能上传速率$u_s+\sum u_i$

在实际应用中，C/S架构随着N的增加最小分发时间线性增长，而P2P则基本趋于一个极限值，在大量N时，明显低于C/S

#### 2.5.2 索引

索引：信息到节点位置（IP+端口号）的映射

集中式索引：中央目录服务器，节点加入时需要通知中央目录服务器，告知IP与内容，用户只需要从中央服务器查找

缺点：内容检索是高度集中的，可能出现单点失效、出现性能瓶颈和版权问题

洪泛式查询：完全分布式架构，每个节点只对它共享的文件进行索引

覆盖网络：如果节点之间有TCP连接，那么构成一个边，所有的节点和边构成覆盖网络，边是虚拟链路，节点一般的邻居少于10

查询消息通过已有的TCP连接发送，节点转发查询消息，如果查询命中，则利用反向路径发回查询节点

层次式覆盖网络：介于集中式与洪泛式之间，每个节点或者是一个超级节点，或者被分配一个超级节点，节点和超级节点之间维持TCP连接，某些超级节点之间维持TCP连接，超级节点负责跟踪子节点的内容

### 2.6 Socket编程

#### 2.6.1 应用编程接口

传输层之下都是操作系统控制，应用层由应用进程控制

位于应用层和传输层之间的接口称为应用编程接口API

应用编程接口API：就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口

几种典型的应用编程接口：

- Socket套接字接口
- WINSOCK，对socket进行了扩展
- TLI，AT&T为其UNIX V定义的API

#### 2.6.2 Socket API概述

最初设计：面向BSD UNIX-Berkley，面向TCP/IP协议栈接口

目前：事实上的工业标准，绝大多数操作系统都支持

通信模型：C/S

端口号：区分应用层的不同的应用进程，16位二进制整数

标识通信端点（对外）：IP地址+端口号

操作系统/进程管理套接字（对内）：套接字描述符，小整数

Socket抽象：

- 类似于文件的抽象
- 当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字的相关信息
- 返回套接字描述符

定义结构`sockaddr_in`：

```c
struct sockaddr_in
{
    u_char sin_len;				/*地址长度*/
    u_char sin_family;			/*地址族*/
    u_short sin_port;			/*端口号*/
    struct in_addr sin_addr;	/*IP地址*/
    char sin_zero[8];			/*未用*/
}
```

TCP/IP地址族：`AF_INET`

#### 2.6.3 Socket编程 - Socket API

以winsock为例

WSAStartup：使用Socket必须首先调用WSAStartup函数，两个参数，第一个指明程序请求的WinSock版本，高位字节指定副版本，低位字节指明主版本；第二个参数返回实际的Winsock的版本信息，这是一个指向WSADATA的指针

WSACleanup：完成对请求的Socket库的使用，最后需要调用，解除与Socket库的绑定，释放资源

socket：创建套接字，创建成功后返回套接字描述符，`sd = socket(protofamily, type, proto)`，第一个参数是协议族，protofamily = PF_INET（TCP/IP），第二个参数是套接字类型，第三个参数为协议号，0为默认

```c
struct protoent *p;
p = getprotobyname("tcp");
SOCKET sd = socket(PF_INET, SOCK_STREAM, p->p_proto);
```

Closesocket(SOCKET sd)：关闭描述符为sd的套接字，如果多个进程共享一个套接字，调用closesocket将套接字的引用计数减1，直至0才关闭。多个线程无法计数，计数以进程为单位。返回值0为成功

bind：`int bind(sd, localaddr, addrlen)`，绑定套接字的本地端点地址：IP地址+端口号，客户端程序通常不需要调用，服务端可使用地址通配符`INADDR_ANY`来绑定多个IP

listen：`int listen(sd, queuesize)`，置服务器端的流套接字处于监听状态，

connect：`connect(sd, saddr, asddrlen)`，客户端调用，连接服务器，UDP时仅用于指定服务器端点地址

accept：`newsock = accept(sd, caddr, caddrlen)`，服务器调用，从处于监听状态的流套接字sd的客户请求队列中取出排在最前面的一个客户请求，并创建一个套接字来与之通信

send、sendto：发送数据，send不需要指定端点地址，适用于TCP或调用了connect的UDP客户端，sendto需要，适用于UDP服务器和未调用connect的UDP客户端

recv、recvfrom：与上面同理

setsockopt、getsockopt：设置/获取套接字参数

TCP/IP定义了独立于操作系统的、用于协议头中的二进制整数表示：网络字节顺序

htons：将本地字节顺序转换为网络字节顺序；ntohs：相反，都是16字节

htonl、ntohl：32字节版本

网络应用的SocketAPI（TCP）调用流程：左为客户端，右为服务器

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7n9soqswmj30ao085tam.jpg)

#### 2.6.4 客户端软件的设计

解析服务器IP地址：

IP协议需要使用32位二进制IP地址，inet_addr()实现点分十进制IP到32位IP的转换，gethostbyname()实现域名到32位IP的转化

解析服务器（熟知）端口号：

客户端使用服务名标示端口，getservbyname()将服务名转换为端口号

解析协议号：

getprotobyname()实现协议名到协议号的转换

TCP客户端软件流程：

1. 确定服务器IP地址与端口号
2. 创建套接字
3. 分配本地端点地址（IP地址和端口）
4. 连接服务器（套接字）
5. 遵循应用层协议进行通信
6. 关闭/释放连接

UDP客户端软件流程：

1. 确定服务器IP地址与端口号
2. 创建套接字
3. 分配本地端点地址（IP地址和端口）
4. 指定服务器端点地址，构造UDP数据报
5. 遵循应用层协议进行通信
6. 关闭/释放套接字

#### 2.6.5 服务器端软件的设计

4种基本类型服务器：循环无连接、循环面向连接、并发无连接、并发面向连接

循环无连接：

1. 创建套接字
2. 绑定端点地址
3. 反复接收来自客户端的请求
4. 遵循应用层协议，构造响应报文，发送给客户

注意，服务器端不能使用connect()函数，无连接服务器使用sendto发送数据报

服务器调用recvfrom()函数接收数据时，自动提取客户端点地址

循环面向连接：

1. 创建套接字，绑定端口号
2. 设置套接字位被动监听模式，准备用于服务器
3. 调用accept函数接收下一个连接请求，创建新套接字用于与该客户建立连接
4. 遵循应用层协议，反复接收客户请求，构造并发送响应
5. 完成特定客户服务后，关闭与该客户之间的连接，返回步骤3

并发无连接：

主线程1：创建套接字，并绑定熟知端口号

主线程2：反复调用recvfrom函数，接收下一个客户请求，并创建新线程处理该客户响应

子线程1：接收一个特定请求

子线程2：根据应用层协议构造响应报文，并调用sendto发送

子线程3：退出

并发面向连接：

主线程1：创建套接字并绑定熟知端口号

主线程2：设置主套接字位被动监听模式，准备用于服务器

主线程3：反复调用accept函数接收下一个连接请求，并创建一个新的子线程处理该客户响应

子线程1：接收一个客户的服务请求

子线程2：遵循应用层协议与特定客户进行交互

子线程3：关闭/释放连接并退出

## 第三章 传输层

### 3.1 传输层服务

传输层协议为运行在不同Host上的进程提供了一种**逻辑通信机制**

端系统运行传输层协议：

发送方：将应用递交的消息分成一个或多个点Segment，并向下传给网络层

接收方：将接收到的segment组装成消息，并向上交给应用层

网络层：提供主机间的逻辑通信机制

传输层：提供应用进程之间的逻辑通信机制，以来于网络层之上，以来于网络层服务器，对网络层进行（可能的）增强

### 3.2 多路复用和多路分用

原因：某层的一个协议对应直接上层的多个协议/实体，则需要复用/分用

分用：

主机接收到IP数据报：每个数据报携带源IP地址、目的IP地址，每个数据报携带一个传输层的段，每个段携带源端口号和目的端口号

主机收到Segment后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket，TCP可能进行更多处理

无连接的分用：

利用端口号创建Socket，UDP的Socket使用二元组标示（目的IP、目的端口）

主机收到UDP段后，检查段中的目的端口号，将UDP段导向绑定在该端口号的Socket，来自于不同源IP地址和/或源端口号的IP数据包被导向同一个Socket

面向连接的分用

TCP的Socket用四元组标识（源IP，源端口，目的IP，目的端口）

接收端利用所有的四个值将Segment导向合适的Socket，服务器可能同时支持多个TCP Socket，每个Socket用自己的四元组标识，Web服务器为每个客户端开不同的Socket

### 3.3 UDP

基于IP协议：做了复用和分用，简单的错误校验

端到端的错误检测原因：无法保证所有链路层协议都有错误检测，路由器存储转发过程中也可能出错

“Best effort”服务，导致UDP段可能丢失或非按序到达

无连接：UDP发送方和接收方无需握手，每个UDP段的处理独立于其他段

UDP存在的价值：

- 无需建立连接（减少延迟）
- 实现简单，无需维护连接状态
- 头部开销少
- 没有拥塞控制，应用可以更好地控制发送时间和速率

常用于流媒体：容忍丢失、速率敏感

UDP还用于DNS和SNMP

在UDP上实现可靠数据传输：在应用层增加可靠性机制、应用特定的错误恢复机制

UDP校验和（checksum）：检测UDP段在传输过程中是否发生错误

发送方：将段的内容看作16bit的整数，计算所有整数的和，进位加在和的后面，将得到的值按位取反，得到校验和

发送方将校验和放入校验和字段

接收方：计算所收到段的校验和，将其与校验和字段进行对比

注意，最高位的进位要加在最低位上

### 3.4 可靠数据传输的基本原理

#### 3.4.1 可靠数据传输原理

什么是可靠：不错、不丢、不乱

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nm69day4j30dw07hgob.jpg)

渐进地设计可靠数据传输协议的发送方和接收方

只考虑单向数据传输，但控制信息双向流动

可以利用状态机（FSM）刻画传输协议

Rdt1.0 可靠信道上的可靠数据传输：

底层信道完全可靠，发送方和接收方的FSM独立

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7nmeiaz4xj30cf02wt9p.jpg)

#### 3.4.2 Rdt 2.0

产生位错误的信道

底层信道可能翻转分组中的位：利用校验和检测位错误

如何从错误中恢复：确认机制（ACK），NAK：接收方显式地告知发送方分组有错误，发送方接收到NAK后，重传分组

基于这种机制的rdt称为ARQ协议

Rdt 2.0引入的新机制：

- 差错i检测
- 接收方反馈控制消息：ACK/NAK
- 重传

停-等协议：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nmm3xkd4j30de07tac9.jpg)

#### 3.4.3 Rdt 2.1和2.2

Rdt 2.0的缺陷：如果ACK/NAK消息发生错误/被破坏

如果ACK/NAK出错，发送方重传

如何解决重复分组的问题：序列号，接收方丢弃重复分组

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nmz68443j30bh07eq5c.jpg)

0和1为序列号

接收方FSM：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nn0l9u5vj30if0ajgqe.jpg)

Rdt 2.2：无NAK消息协议

如Rdt 2.1功能相同，但只用ACK

接收方通过ACK告知最后一个被正确接收的分组：在ACK消息中显式地加入被确认分组的序列号

发送方收到重复ACK之后，采取与收到NAK相同的动作：重传当前分组

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nn728vd8j30io0b143h.jpg)

#### 3.4.4 Rdt 3.0

信道即可能发生错误，也可能丢失分组

“校验和 + 序列号 + ACK + 重传”不够用

方法：发送方等待“合理时间”，如果没收到ACK，重传

需要定时器

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nnc6rk3xj30gc0aiq7e.jpg)

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7nni8tnb2j30jq0a7429.jpg)

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7nnkfox1fj30j30a50x3.jpg)

Rdt 3.0性能很差

性能举例：

1Gbps链路，15ms端到端传播延迟，1KB分组
$$
T_{transmit} = \frac{L}{R} = \frac{8kb/pkt}{10^9b/sec} = 8 microsec
$$
发送方利用率：发送方发送时间的百分比
$$
U_{sender} = \frac{L/R}{RTT + L / R} = \frac{0.008}{30.008} = 0.00027
$$
在1Gbps的链路上每30ms才发送一个分组：33KB/sec

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7odi54y25j30i609njts.jpg)

### 3.5 滑动窗口协议

#### 3.5.1 流水线机制与滑动窗口协议

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7odm7a813j30g108nacn.jpg)

流水线协议：允许发送方在收到ACK之前发送多个分组

更大的序列号范围，发送方和接收方需要更大的存储空间以缓存分组

滑动窗口协议：

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7odp62ztqj30ai02h74q.jpg)

绿色为已经发送完成且确认的分组，黄色为已经发送但还未确认的分组，蓝色表示还可以使用的序列号范围，白色为还未使用的序列号范围

窗口：允许使用的序列号范围，尺寸在N：最多有N个正在等待确认的消息

窗口在**序列号空间**向前滑动

滑动窗口协议包括GBN、SR

#### 3.5.2 GBN（Go-Back-N）协议

发送方：

分组头部包含k-bit序列号，窗口尺寸为N，最多允许N个分组未确认

ACK(n)：确认到序列号n（包含n）的分组都已经被正确接收

未空中的分组设置定时器

如果出现Timeout(n)事件，则重传序列号大于等于n，还未收到ACK的所有分组

接收方：

ACK机制，发送拥有最高序列号的、已被正确接收的分组的ACK

乱序到达的分组：1. 直接丢弃，2. 重新确认序列号最大的、按序到达的分组

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7oe6w1a6aj30br0abjum.jpg)

#### 3.5.3 SR（Selective Repeat）协议

接收方对每个分组单独确认，设置缓存机制，缓存乱序到达的分组

发送方只重传那些没收到ACK的分组，为每个分组设置定时器

发送方窗口：N个连续的序列号，限制已发送且未确认的分组

SR有接收方的窗口：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7oei4um7dj30g908w40q.jpg)

注意，如果接收方接收到的分组不在窗口中，依旧需要发送ACK以更新发送方窗口

困境，接收方无法辨别这两种情况：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7oevidrrxj307p0awtbb.jpg)

解决：
$$
N_S+N_R\le 2^k
$$

### 3.6 面向连接传输协议——TCP

#### 3.6.1 TCP概述

特点：

点对点：一个发送方，一个接收方

可靠的、按序的字节流

流水线机制：TCP拥塞控制和流量控制机制设置窗口尺寸，介于GBN和SR，发送方和接收方都有缓存

全双工：同一连接中能够传输双向数据流

面向连接：通信双方在发送数据之前必须建立连接，连接状态由连接两端维护，TCP的连接包括：两台主机的缓存、连接状态变量、Socket等

具有流量控制机制

TCP段结构：

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7ogrcjpypj30fw09nwiv.jpg)

序列号：序列号是Segment中第一个字节的编号，而不是segment的编号，建立TCP连接时，双方随机选择序列号

ACKs：希望接收到的下一个字节的序列号，累积确认：该序列号之前的所有字节均已被正确接收

乱序Segment：TCP无规定，由实现者做出决策

Telnet举例：

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7ogw4v0fgj308d09e75u.jpg)

#### 3.6.2 TCP可靠数据传输

TCP在IP层提供的不可靠服务的基础上实现可靠数据传输服务

流水线机制、累积确认、单一重传定时器

触发重传的事件：超时、收到重复的ACK

渐进式：暂不考虑重复ACK、暂不考虑流量控制、暂不考虑拥塞控制

RTT和超时：

设定定时器的超时时间：大于RTT

估计RTT：SampleRTT，测量多个求平均，形成估计值EstimatedRTT

EstimatedRTT的更新：
$$
EstimatedRTT = (1 - \alpha)*EstimatedRTT + \alpha * SampleRTT\\
\alpha 典型值为0.125
$$
超时时间 = EstimatedRTT + “安全边界”

如果EstimatedRTT变化较大，就需要较大的边界，就需要测量RTT的变化值：
$$
DevRTT = (1-\beta)*DevRTT + \beta * |SampleRTT - EstimatedRTT|\\
通常，\beta=0.25
$$
最终，定时器的超时时间为：
$$
TimeoutInterval = EstimatedRTT + 4 * DevRTT
$$
TCP发送方事件：

- 创建Segment
- 序列号是Segment第一个字节的编号
- 开启计时器
- 设置超时时间

如果出现超时：重传引起超时的Segment，重启定时器

如果收到ACK：

如果确认此前未确认的Segment，则更新SendBase，如果窗口还有未被确认的分组，则重启定时器

TCP接收方：

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7ohw40eu2j30e508hn1s.jpg)

快速重传机制：

原机制如果发生超时，超时时间间隔将加倍

该机制通过重复ACK检测分组丢失，如果某个分组丢失，可能会引发多个重复的ACK

如果发送方收到对同一数据的3个ACK，则假定该数据之后的段已经丢失，则会在定时器超时之间进行重传

#### 3.6.3 TCP流量控制

接收方为TCP连接分配buffer，buffer中的数据将缓缓交付给上层

流量控制就是保证发送方不会传输太多、太快以至于淹没接收方buffer

假定TCP接收方丢弃乱序段：

buffer中的可用空间 = RcvBuffer - ( LastByteRcvd - LastByteRead )

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7oial872rj309403p752.jpg)

接收方a经通过在段中的头部字段将RcvWindow告诉发送方，发送方将限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲尺寸

如果RcvWindow=0，会导致死锁，即时空闲之后无法通知

实际上，发送方在这种情况下仍然可以发送很小的段以保证不陷入死锁

#### 3.6.4 TCP连接管理

发送方和接收方在传输数据前需要建立连接

三次握手：

1. 客户端发送SYN报文段到服务器，将SYN报文段置为1，并传递初始序列号
2. 服务器收到SYN，返回SYNACK报文段，此时服务器分配缓存，并选择自己的初始序列号并告知客户端
3. 客户端收到SYNACK，并返回ACK，用于与服务器确认收到同意建立连接的报文段，可以包含数据

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7oikfkkm7j30df09ljt3.jpg)

四次挥手：

1. 客户端向服务器发送TCP FIN
2. 服务器收到FIN ，回复ACK，关闭连接，发送FIN
3. 客户端收到FIN，回复ACK，此时进入等待时间，如果收到FIN，就会重新发送ACK，等待时间结束后关闭连接
4. 服务器收到ACK，连接关闭

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7oiqqzphtj307x07ydgv.jpg)

### 3.7 拥塞控制原理

拥塞：分组丢失、分组延迟（排队延迟）过大

拥塞的成因与代价：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7vcg8irswj309404b754.jpg)

两个senders，两个receivers，一个路由器，无限缓存，没有重传

代价：时延过大

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7vclwxsl0j30ba05oq4a.jpg)

一个路由器，有限buffers，Sender重传分组

情况a：Sender能获知buffer信息，$\lambda_{in}=\lambda_{out}$（goodput）

情况b：丢失后才重发：$\lambda_{in}>\lambda_{out}$

情况c：分组丢失和定时器超时后都重发，$\lambda_{in}$变得更大

代价：对给定的goodput，需要更多的工作（重传），造成资源的浪费

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7vcsdcsu2j30b205ymyz.jpg)

四个发送方，多跳，超时/重传

代价：当分组被drop掉时，任何用于该分组的上游传输能力全都被浪费掉

拥塞控制的方法：

端到端拥塞控制：端系统通过观察loss、delay来判断是否发生拥塞

网络辅助拥塞控制：路由器向发送方显式反馈网络拥塞信息，简单的拥塞指示（1bit）：SNA、DECbit、TCP/IP ECN、ATM，指示发送方应当采取何种速率

ATM ABR（网络辅助）：

“弹性服务”，如果发送方路径负载低，就会使用可用带宽，如果发送方路径拥塞，就会将发送速率降到最低保障速率

RM cells：由发送方发送，交换机设置RM cell位：NI bit速率不许增长，CI bit已经拥塞，RM cell由接收方返回给发送方

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7vdjt9z2oj30a8046js6.jpg)

每隔一个Data cell就会插入一个RM cell，RM cell中有显式的速率（ER）字段：两个字节

数据cell中有EFCI位：拥塞的交换机将其设为1

### 3.8 TCP拥塞控制

#### 3.8.1 TCP拥塞控制

Sender限制发送速率：
$$
LastByteSend - LastByteAcked\le CongWin\\
rate = \frac{CongWin}{RTT}Bytes/sec
$$
CongWin：动态调整以改变发送速率，反应所感知到的网络拥塞

感知网络拥塞：

Loss时间：timeout或三个重复ACK

发生loss事件后，发送方降低速率

调整：加性增-乘性减：AIMD

满启动：SS

加性增-乘性减，AIMD：

逐渐增加发送速率，谨慎探测可用带宽，直到发生loss

每个RTT将CongWin增大一个MSS，发送loss后将CongWin减半

图形为锯齿形

TCP满启动，SS：

TCP建立时，CongWin=1，可用带宽远远高于初始速率

原理：当连接开始时，指数性增长

保障在每个RTT，CongWin翻倍，在每次收到RTT时进行操作

策略切换：Threshold变量

当CongWin达到Loss事件前值当1/2时

实现方法：设置变量Threshold，Loss事件发生时，Threshold被设为Loss事件前CongWin的1/2

Loss事件处理：

- 三个重复ACKs：CongWin切到一半，之后线性增长
- Timeout（更为严重的拥塞）：CongWin设为1个MSS，然后指数增长

#### 3.8.2 TCP性能分析

TCP throughput：吞吐率

给定拥塞窗口大小和RTT，忽略Slow Start

发生超时时CongWin为W，吞吐率为W / RTT

超时后，CongWin=W/2，平均吞吐率为0.75W/RTT

## 第四章 网络层

### 4.1 网络层服务

- 从发送主机向接收主机传送数据段

- 发送主机：将数据段封装为数据报中

- 接收主机：向传输层交付数据段

每个主机和路由器都运行网络层协议，路由器检验所有穿越它的IP数据报的头部域，以决定如何处理IP数据报

核心功能：转发与路由

转发：将分组从路由器的输入端口转移到合适的输出端口

转发表：转发表确定在本路由器如何转发分组

路由：确定分组从源到目的路径经过的路径

路由算法：确定分组通过网络的端到端的路径

网络层核心功能：连接建立

数据分组传输之间两端主机需要首先建立虚拟/逻辑连接，网络设备（如路由器）参与连接的建立

网络层连接：两个主机之间（路径上的路由器等网络设备参与其中）

传输层连接：两个应用进程之间（对中间网络设备透明）

网络层服务模型：

- 无连接服务：不事先为系列分组的传输确定传输路径，每个分组独立确定传输路径，不同分组可能传输路径不同，例如数据报网络
- 连接服务：首先为系列分组的传输确定从源到目的经过的路径，然后沿该路径传输系列分组，系列分组传输路径相同，传输结束后拆除连接，例如虚电路网络

### 4.2 虚电路网络与数据报网络

#### 4.2.1 虚电路网络

网络层服务：主机到主机服务，网络核心实现

虚电路：一条从源主机到目的主机，类似于电路的路径（逻辑连接）

- 分组交换
- 每个分组的传输利用链路的全部带宽
- 源到目的路径经过的网络层设备共同完成虚电路功能

通信过程：

- 呼叫建立——数据传输——拆除呼叫
- 每个分组携带虚电路标识（VCID），而不是目的主机地址
- 虚电路经过的每个网络设备，维护每条经过它的虚电路连接状态
- 链路、网络设备资源（如宽带、缓存等）可以面向VC进行预分配，预分配资源=可预期服务性能

每条虚电路包括：

1. 从源主机到目的主机到一条路径
2. 虚电路号（VCID），沿路每段链路一段编号
3. 沿路每一个网络层设备，利用转发表记录经过的每条虚电路

沿着某条虚电路传播的分组，携带对应虚电路的VCID，而不是目的地址，同一条VC，在每段链路上的VCID不同，路由器负责在转发分组时依据转发表改写/替换虚电路号

路由器负责记录输入接口对应的VCID和输出接口对应的VCID及其对应关系

虚电路信令协议：用于VC的建立、路径选择、维护与拆除

目前Internet不采用，Internet为数据报网络

#### 4.2.2 数据报网络

网络层无连接，每个分组都携带目的地址，路由器根据分组的目的地址转发分组

路由器基于路由协议/算法构建转发表，每个分组独立选路

路由算法（协议）确定通过网络的端到端路径，转发表确定在本路由器如何转发分组

转发表的目的地址表示为地址范围

最长前缀匹配优先：如果遇到前缀存在部分相同的，选择匹配的前缀最长的地址范围对应的链路接口

数据报网络（Internet）与虚电路网络（ATM）对比：

Internet：计算机之间的数据交换，弹性服务，没有严格的时间需求；链路类型众多，统一困难；智能端系统，可以自适应、性能控制、差错恢复

简化网络，复杂边缘

ATM：电话网演变而来；核心业务时实时对话，严格的时间、可靠性需求，需要有保障的服务；非智能的端系统

简化边缘，复杂网络

### 4.3 IPv4协议

#### 4.3.1 IP数据报

Internet网络层主要功能：

- 路由协议：路径选择，RIP、OSPF、BGP
- IP协议：寻址规约，数据报（分组）格式，分组处理格式
- ICMP协议：差错报告，路由器信令

IP数据报（分组）格式：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g89gdbxdm4j30du08440g.jpg)

版本号：四位，IP协议的版本号，4或6

首部长度：四位，IP分组首部长度，实际首部大小为标称长度*4

服务类型：八位，指示期望哪种类型的服务，只有在网络区分服务时使用，一般不使用，通常值为00H

总长度：占16位，IP分组的总字节数（首部+数据）

生存时间：TTL， 八位，IP分组在网络中可以通过的路由器数（跳步数），每一次转发，TTL减一，若TTL=0，丢弃

协议：八位，指示IP分组封装哪个协议的数据包，实现复用/分解

首部校验和：16位，实现对IP分组首部的差错检测，计算校验和时，该字段全0，反码运算求和，和的反码，逐跳计算，逐跳校验

源IP、目的IP：各占32位

选项：长度可变，1～40B，携带安全、源选路径、时间戳和路由记录等，实际很少被使用

填充：长度可变，0～3B，补齐首部，符合32位对齐，保证首部长度是4字节倍数

#### 4.3.2 IP数据报分片

最大传输单元：MTU

链路层数据帧可封装数据的上限，不同链路的MTU是不同的

当大IP分组向较小MTU链路转发时，可以被分片

IP分片**到达目的主机之后**进行重组

IP首部相关字段用于标识分片以及确定分片顺序：总长度、标识、标志位、片偏移

标识：16位，标识一个IP分组，IP协议利用一个计数器，每产生IP分组计数加1，作为该分组的标识

标志位：3位，第一位保留，之后分别为DF（禁止分片）和MF（更多分片）

DF=1:禁止分片，DF=0:允许分片，MF=1:不是最后一片，MF=0:最后一片（或未分片）

片偏移：13位，一个IP分组分片封装原IP分组数据的相对偏移量，片偏移字段以8字节为单位

IP分片的过程：假设原IP分组总长度为L，待转发链路的MTU为M

若L>M，且DF=0，则可以/需要分片

- 分片时每个分片的标识赋值原IP分组的标识
- 通常分片时，除了最后一个分片，其他分片均分为MTU允许的最大分片
- 









### 4.9 路由算法

#### 4.9.1 路由算法

网络抽象：图G=（N，E）

N=路由器集合，E=链路集合

费用Costs：链路权值，c(x, x')=链路(x, x')的费用

一般取费用越小越好，例如带宽的倒数或拥塞程度等

关键问题：源到目的的最小费用路径是什么，路由算法实质上是寻找最小路径算法

路由算法分类：

静态路由 VS 动态路由？

静态路由：手工配置，路由更新慢，优先级高

动态路由：路由更新快（定期更新，及时响应链路费用或拓扑变化）

全局信息 VS 分散信息？

全局信息：所有路由器掌握完整的网络拓扑和费用信息，如链路状态路由算法

分散信息：路由器只掌握物理相连的邻居以及链路费用，邻居间信息交换、运算的迭代过程，如距离向量路由算法

#### 4.9.2 链路状态路由算法

Dijkstra算法

需要所有节点（路由器）掌握网络拓扑和链路费用，通过“链路状态广播”，类似泛洪，所有的节点拥有相同的信息

计算一个源出发到达其他节点的最短路径，获得该节点的转发表

迭代：经过k次迭代后，得到到达k个目的节点的最短路径

描述符号：

$c(x,y)$：节点x到节点y到链路费用，若无直接相连，$c(x,y)=\infin$

$D(v)$：从源到目的v到当前路径费用值

$p(v)$：沿从源到v到当前路径，v到前序节点

$N'$：已经找到的最小费用路径的节点集合

算法描述（以节点u为例）：

初始化：

```
N'={u}
for 所有节点v:
	if v毗邻u
		then D(v)=c(u,v)
	else
		D(v)=∞
```

循环

```
Loop
找出不在N'中的w，满足D(w)最小
将w加入N'
更新w的所有不在N'中的邻居v的D(v)：
	D(v)=min(D(v), D(w) + c(w, v))
Until 所有节点都在N'中
```

最终获得最短路径树，并确定最终转发表

算法复杂性：n个节点的情况下

每次迭代：需要检测所有不在集合N'中的节点w

n(n+1)/2次比较：O($n^2$)，存在更高效的实现$O(nlogn)$

存在震荡的可能（假设链路费用是该链路承载的通信量）

