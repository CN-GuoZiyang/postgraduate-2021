# 一 操作系统概述

## 1 操作系统的基本概念

### 1.1 概念（定义）

操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其它软件方便的接口和环境，它是计算机系统中最基本的系统软件。

1. 操作系统是系统资源的管理者
2. 向上层提供方便易用的服务
3. 是最接近硬件的一层软件

### 1.2 功能和目标

#### 1.2.1 作为系统资源的管理者

1. 处理器管理
2. 存储器管理
3. 文件管理
4. 设备管理

#### 1.2.2 向上层提供方便易用的服务

封装思想，将底层的硬件功能封装成简单易用的服务

提供的服务：

- GUI（Graphical User Interface）
- 命令接口，联机命令接口和脱机命令接口。联机命令接口=交互式命令接口，脱机命令接口=批处理命令接口
- 程序接口，即系统调用，只能通过程序代码间接使用

有时，命令接口和程序接口统称为用户接口

#### 1.2.3 最接近硬件的层次

需要实现对硬件机器的拓展。

没有任何软件支持的计算机称为裸机，覆盖了软件的机器称为扩充机器，或虚拟机。

### 1.3 四个特征

并发，共享，虚拟，异步。

并发和共享是两个最基本的特征，互为存在条件

#### 1.3.1 并发

两个或多个事件在同一时间间隔内发生，这些事件在宏观上同时，在微观上交替

并行是同时发生

操作系统的并发性指计算机同时运行着多个程序，操作系统是伴随着“多道程序技术”出现的，因此操作系统和程序并发是一起诞生的。

注意：单核CPU同一时刻只能执行一个程序，程序只能并发执行；多核CPU同一时刻克同时执行多个程序，程序可以并行地执行。

并发性是操作系统的基本特性

#### 1.3.2 共享

资源共享，系统资源可供内存中多个并发执行的进程共同使用。

两种方式：互斥共享方式和同时共享方式

互斥共享方式：一个时间段内只允许一个进程访问该资源。

同时共享方式：允许一个时间段内多个进程“同时”（宏观上）对它们进行访问。

#### 1.3.3 并发与共享的关系

如果失去并发性，则系统只用一个程序正在运行，则共享性失去存在的意义

如果失去共享性，则不通程序无法同时使用资源，无法实现并发

#### 1.3.4 虚拟

把物理上的实体变为若干逻辑上的对应物，物理实体是实际存在的，逻辑对应物是用户感受到的。

如虚拟处理器技术（时分复用技术）和虚拟存储器技术（空分复用技术）

没有并发性，谈不上虚拟性

#### 1.3.5 异步

在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。

只有系统拥有并发性，才有可能导致异步性。

## 2 操作系统的发展与分类

### 2.1 手工操作阶段

打孔程序，装取纸带、读写纸带速度慢，计算速度快，用户独占，资源效率低下

### 2.2 批处理阶段

#### 2.2.1 单道批处理系统

引入脱机输入/输出技术（外围机+磁带），由监督程序负责控制作业的输入输出

计算机直接向磁带上IO，速度快

监督程序是操作系统的雏形

内存中只有一道程序在运行，CPU有大量的时间在等待IO

#### 2.2.2 多道批处理系统

操作系统诞生

计算的同时可以进行IO，支持多道程序并发允许

没有人机交互功能，响应时间长

### 2.3 分时操作系统

计算机以时间片为单位轮流给各个用户/作业服务，各个用户可通过终端与计算机交互

用户请求可以被即时响应，解决了人际交互的问题，用户操作相对独立

不能有限处理一些紧急任务

### 2.4 实时操作系统

能优先响应一些紧急的任务，某些紧急任务不需要时间片排队

计算机系统接收到外部信号后及时进行处理，且要在严格的时限内处理完事件

及时性和可靠性

### 2.5 其它操作系统

网络操作系统，分布式操作系统，个人计算机操作系统

## 3 操作系统的运行环境

### 3.1 运行机制

#### 3.1.1 内核程序 VS 应用程序

普通程序就是应用程序

为了实现操作系统而编写的程序称为内核程序，内核程序组成操作系统内核，简称内核，内核是操作系统最重要最核心的部分，也是最接近硬件的部分

Docker -> 仅需Linux内核

内核作为管理者，可能会让CPU执行特权指令，如：内存清零指令，这些指令只允许内核使用。CPU在设计和生产时已经划分了特权与非特权指令，CPU在执行一条指令前就能判断其类型。

#### 3.1.2 内核态 VS 用户态

CPU判断此时运行程序类型的依据

CPU的两种状态，内核态和用户态，当处于内核态时，说明此时运行的是内核程序，可以执行特权指令，若处于用户态，则运行的是应用程序，只能执行非特权指令

CPU中的一个寄存器，程序状态字寄存器（PSW），其中有一个二进制位，1表示内核态，0表示用户态（不一定）

别名：内核态=核心态=管态，用户态=目态

转换：内核态CPU可执行一条特权指令将CPU状态转换为用户态（主动让出），用户态程序执行时若遇到异常，会触发一个中断信号，使CPU变为核心态，并停止当前应用程序，执行中断处理程序（强制夺回）。

### 3.2 中断和异常

#### 3.2.1 中断的作用

中断是操作系统内核夺回CPU使用权的唯一途径，如果没有中断机制，那么应用程序一旦在CPU上运行，就会一直运行下去，无法实现并发

内核态 -> 用户态：执行一条特权指令——修改PSW的标志位为用户态（主动让出）

用户态 -> 内核态：由中断引发，硬件自动完成变态过程

#### 3.2.2 中断的类型

内中断与外中断

内中断与当前执行的指令有关，中断信号来源于CPU内部

外中断与当前执行的指令无关，中断信号来源于CPU外部

例如，应用程序请求操作系统内核服务，会执行一条指令——陷入指令，该指令会引发一个内部中断信号。（系统调用）

时钟中断，来自时钟部件发来的信号，外中断

I/O中断，由输入/输出设备发来的中断信号

内中断又称为异常，外中断也称为中断

#### 3.2.3 中断的分类

陷阱、陷入（trap），故障（fault），终止（abort）

陷阱、陷入：陷入指令引发，故意引发

故障：错误条件引起，可能被修复，修复完成后可以继续运行，如缺页故障

终止：由致命错误引起，内核程序无法修复该错误，直接终止应用程序，如除零异常、非法使用特权指令

#### 3.2.4 中断机制的基本原理

不同的中断信号，需要不同的中断处理程序来处理。

中断向量表记录了中断处理程序在内存中的存放位置。

中断处理程序是一种内核程序，运行在内核态下。

### 3.3 系统调用

#### 3.3.1 概念

系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。

#### 3.3.2 系统调用的功能

1. 设备管理：完成设备的请求/释放/启动等功能
2. 文件管理：完成文件等读/写/创建/删除等功能
3. 进程控制：完成进程的创建/撤销/阻塞/唤醒等功能
4. 进程通信：完成进程之间的消息传递/信号传递等功能
5. 内存管理：完成内存的分配/回收等功能

与共享资源有关的操作，都必须通过系统调用的方式向操作系统内核提供请求

#### 3.3.3 系统调用的过程

1. 传参指令，传递必要的参数，指明系统调用的类型，以及其它必要参数
2. 陷入指令，引发内中断信号，CPU进入内核态，并转入响应的中断处理程序，即系统调用的入口程序
3. 入口程序根据寄存器中的参数判断系统调用服务的类型，并调用相应系统调用的处理程序

注意：陷入指令是在用户态执行的，引发内中断，使CPU进入核心态

别名：陷入指令=trap指令=访管指令

### 3.4 操作系统的体系结构

操作系统内核可分为**时钟管理、中断处理、原语**、进程管理、存储器管理、设备管理等功能。

原语（设备驱动、CPU切换等）是一种特殊的程序，具有原子性，不可被中断。

分类：大内核、微内核

微内核仅包括时钟管理、中断处理、原语，而大内核还包括进程管理、存储管理、设备管理等

内核包括等模块需要运行在内核态，其它模块都运行在用户态

切换状态是有成本的，频繁地切换状态会降低系统性能

# 二 进程管理

## 1 进程与线程

### 1.1 进程的概念、组成、特征

#### 1.1.1 进程的概念

程序：静态的，存放在磁盘里的可执行文件，指令集合

进程：动态的，程序的一次执行过程

#### 1.1.2 进程的组成

PID：进程ID（Process ID），唯一的，不重复的

UID：进程所属用户ID

操作系统需要记录PID、UID、分配的资源（内存、IO、文件）、运行情况（CPU使用时间、磁盘使用情况、网络流量）

这些信息会被保存在一个数据结构PCB（Process Control Block）中，即进程控制块

PCB是进程存在的唯一标志，与进程共同创建共同销毁

PCB的组成：

- 进程描述信息：PID、UID
- 进程控制和管理信息：CPU、磁盘、网络使用情况统计，进程当前状态（就绪态、阻塞态、运行态）
- 资源分配清单：正在使用的文件、内存区域、IO设备
- 处理器相关信息：PSW、PC等寄存器的值（用于实现进程切换）

进程的组成：PCB、程序段（程序的代码，指令序列）、数据段（运行过程中产生的数据，如程序定义的变量）

PCB是给操作系统用的，程序段、数据段是给进程自己用的

进程实体（进程映像、快照）是由PCB、程序段、数据段组成，进程是动态的，进程实体是静态的

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

#### 1.1.3 进程的特征

- 动态性（最基本）：进程是程序的一次执行过程，是动态地产生、变化和消亡的
- 并发性：内存中有多个进程实体，各进程可并发执行
- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统提供“进程同步机制”来解决异步问题
- 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

### 1.2 进程的状态与转换

#### 1.2.1 状态

- 创建态：进程正在被创建，该阶段操作系统为进程分配资源、初始化PCB
- 就绪态：创建完成后，进入就绪态，具备运行条件，没有空闲CPU
- 运行态：在CPU上运行，CPU执行该进程对应的程序
- 阻塞态：进程在请求等待某个事件的发生（资源分配，其它进程的响应），无法继续执行，操作系统会让该进程下CPU，进入阻塞态
- 终止态：进程执行exit系统调用，请求操作系统终止该进程，进程进入终止态，操作系统会让该进程下CPU，回收内存空间等资源，回收PCB

基本状态：运行态，就绪态，阻塞态

别名：阻塞态=等待态，创建态=新建态，终止态=结束态

在PCB中，有变量state表示进程当前的状态

#### 1.2.2 状态转换

![](http://ww4.sinaimg.cn/large/006tNc79gy1g5pq9el9szj30jo0bjn3c.jpg)

#### 1.2.3 进程的组织方式

链接方式

分为三个指针（队列）

- 执行指针：指向当前处于运行态（执行态）的进程，单CPU计算机中，同一时刻只会有一个进程处于运行态
- 就绪队列指针：指向当前处于就绪态的进程，通常会把优先级高的进程放在队头
- 阻塞状态指针：指向处于阻塞状态的进程，有时会因为阻塞原因的不同而分为多个队列

索引方式：

索引表

### 1.3 进程控制

#### 1.3.1 概念

对系统中所有进程实施有效的管理，如创建新进程、撤销已有进程、实现进程状态转换等

#### 1.3.2 实现

使用原语实现，执行具有原子性，不可中断

原语使用“关中断指令”和“开中断指令”这两个特权指令来实现原子性

关中断指令使得CPU不再例行检查中断信号，直到执行开中断指令后才会恢复。

##### 1.3.2.1 相关原语

创建原语：即创建一个进程时使用的原语

- 申请空白PCB
- 为新进程分配所需资源
- 初始化PCB
- 将PCB插入就绪队列

引起进程创建的事件：

- 用户登录
- 作业调度
- 提供服务
- 应用请求

撤销原语：终止一个进程所需的原语

- 从PCB集合中找到终止进程的PCB
- 若程序正在执行，剥夺CPU，将CPU分配给其它进程
- 终止其所有子进程
- 将该进程拥有的所有资源归还给父进程或操作系统
- 删除PCB

引起进程终止的事件：

- 正常结束（exit系统调用）
- 异常结束（除0，强行使用特权指令）
- 外界干预（用户手动）

阻塞原语：

- 找到要阻塞的进程对应的PC吧
- 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
- 将PCB插入相应事件的等待队列

引起进程阻塞的事件：

- 需要等待系统分配某种资源
- 需要等待相互合作的其它进程完成工作

唤醒原语：

- 在事件等待队列中找到PCB
- 将PCB从等待队列移除，设置进程为就绪态
- 将PCB插入就绪队列，等待被调度

引起进程唤醒的事件：

- 等待的事件发生（因何事被阻塞，就因何事被唤醒）

切换原语：

- 将运行环境信息存入PCB
- PCB移入相应队列
- 选择另一个进程执行，并更新其PCB
- 根据PCB恢复新进程所需的运行环境

引起进程切换的事件：

- 当前进程时间片结束
- 有更高优先级的进程到达
- 当前进程主动阻塞
- 当前进程终止

CPU中的重要寄存器：

PSW：程序状态字寄存器

PC：程序计数器，存放下一条指令地址

IR：指令寄存器，存放当前正在执行的指令

### 1.4 进程通信

#### 1.4.1 概念

进程之间的信息交换

由于进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立

为了保证安全，一个进程无法直接访问另一个进程的地址空间

#### 1.4.2 共享存储

操作系统提供共享空间，两个进程都可读写，以实现通信

两个进程对共享空间的访问必须是互斥的，操作系统提供同步互斥工具（如P、V操作）

分为：基于数据结构的共享和基于存储区的共享

基于数据结构的共享：共享空间只能存放固定的数据结构，速度慢，限制多，低级

基于存储区的共享：数据形式、存放位置由进程提供，速度快，高级

#### 1.4.3 管道通信

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区

注意：

1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要两个管道
2. 各进程需要互斥地访问管道
3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞
4. 如果没有写满，则不允许读，反正同理
5. 数据一旦被读出，就会被抛弃，意味着读进程最多只有一个

#### 1.4.4 消息传递

以格式化的消息为单位，进程通过操作系统提供的“发送/接收消息”两个原语进行数据交换

消息分为消息头和消息体，消息头包括：发送进程ID，接收进程ID，消息类型，消息长度等

消息传递分为：直接通信方式和间接通信方式

直接通信方式：消息直接挂到接收进程的消息缓冲队列尾

间接通信方式：消息要先发送到中间实体（信箱）中，因此也被称为“信箱通信方式”

### 1.5 线程的概念与特点

#### 1.5.1 概念

引入线程后，线程是CPU调度的基本单位

进程仍然是资源分配的基本单位，从属于同一进程的各个资源共享进程的资源

#### 1.5.2 特性和优点

并发时不需要进行进程切换，无需切换内存地址空间，节省资源

从属同一进程的各个线程共享进程拥有的资源

同进程下线程的通信，无需操作系统干预，开销小

线程也有运行态、就绪态、阻塞态

在多CPU环境下，各个线程也可以被分派到不同CPU并发

线程几乎不拥有资源，只有极少量资源（线程控制块TCB，寄存器信息，堆栈）

### 1.6 线程的实现方式和多线程模型

#### 1.6.1 线程的实现方式

用户级线程（User-Level Thread，ULT）：早期操作系统，只支持进程，不支持线程，当时线程由线程库实现

注意：

1. 线程管理工作由线程库来完成

2. 线程切换无需CPU切换状态

3. 操作系统不知道用户级线程的存在

4. 优点：无需切换CPU状态，线程管理开销小，效率高

    缺点：当一个用户级线程被阻塞，整个进程都会被阻塞，并发度不高，多个线程无法在多核处理器上并发运行。

内核级线程（Kernel-Level Thread，KLT）：由操作系统支持的线程

注意：

1. 线程的管理工作由操作系统完成

2. 线程切换需要CPU切换状态

3. 操作系统意识到内核级线程的存在

4. 优点：当一个线程被阻塞时，别的线程还可以继续执行，并发能力强，可在多核处理器上并行执行

    缺点：一个进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，导致线程管理成本高，开销大

#### 1.6.2 多线程模型

一对一模型：每个用户级线程映射到一个内核级线程。咩歌用户进程有与用户级线程同等数量的内核级线程。

优点：并发能力强，可在多核处理器上并发。缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统完成，需要切换到核心态，线程管理成本高，开销大

多对一模型：多个用户级线程映射到一个内核级线程，一个进程只被分配一个内核级线程

优点：线程切换在用户空间即可完成，无需切换到核心态，线程管理系统开销小，效率高。缺点：一个用户级线程被阻塞后，整个进程都会阻塞，并发度不高，无法在多核处理器上并发运行

注意：只有内核级线程才是处理器的分配单位

多对多模型：n个用户级线程映射到m个内核级线程（n>=m），每个用户进程对应m个内核级线程。

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 2 处理器调度

### 2.1 处理器调度的概念和层次

#### 2.1.1 概念

在多道程序系统中，进程的数量往往是多于处理器个数的，无法同时并行地处理各个进程

处理器调度，就是从就绪队列当中按照一定的算法选择一个进程并将处理器分配给它运行，以实现进程的并发执行

#### 2.1.2 层次

##### 2.1.2.1 高级调度

高级调度（作业调度），按照一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，给它们分配内存等资源，并建立相应的进程（PCB），使得它们获得竞争处理器的权利

高级调度是外存与内存之间的调度，每个作业只调入一次，调出一次，作业调度时会建立相应的PCB，作业调出时才撤销PCB。调入的时机需要操作系统来确定，调出的时机是作业运行结束后调出。

##### 2.1.2.2 中级调度

引入虚拟存储技术后，可以暂时将不能运行的进程调至外存等待，等其重新具备了运行条件且内存有空间，再掉入内存。

目的：提高内存利用率和系统吞吐量

暂时调到外存等待的进程进入挂起状态，然而，PCB不会一起被调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放的位置、进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存，一个进程可能会被多次调入、调出内存，因此中级调度发生的频率要比高级调度更高

##### 2.1.2.3 低级调度

低级调度（进程调度），按照某种方法和策略从就绪队列中选择一个进程，将处理器分配给它

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度

进程调度很高

##### 2.1.2.4 对比

|                      |                        要做什么                        |       发生位置       | 发生频率 |            对进程状态的影响            |
| :------------------: | :----------------------------------------------------: | :------------------: | :------: | :------------------------------------: |
| 高级调度（作业调度） | 从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存 -> 内存（作业） |    低    |         无 -> 创建态 -> 就绪态         |
| 中级调度（内存调度） |       从挂起队列中选择合适的进程将其数据调回内存       | 外存 -> 内存（进程） |    中    | 挂起态 -> 就绪态（阻塞挂起 -> 阻塞态） |
| 低级调度（进程调度） |         从就绪队列中选择一个进程为其分配处理器         |     内存 -> CPU      |    高    |            就绪态 -> 运行态            |

#### 2.1.3 进程的七状态模型

挂起状态可以分为就绪挂起和阻塞挂起两种状态。

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5s0rp71ikj30lg091aee.jpg)

### 2.2 进程调度的时机、切换与过程、调度方式

#### 2.2.1 时机

进程调度（低级调度），按照某种算法从就绪队列中选择一个进程为其分配处理器

主动放弃：进程正常终止，发生异常终止，主动请求阻塞（I/O）

被动放弃：时间片用尽，有更紧急的事情要处理（I/O中断），有更高优先级的进程进入就绪队列

不能进行进程调度与切换的情况：

1. 在处理中断的过程中
2. 进程在操作系统内核临界区中
3. 原子操作过程（原语）中

临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源

临界区就是访问临界资源那段代码

内核程序的临界区一般是用来访问某种内核数据结构的，如进程的就绪队列

内核程序临界区访问的临界资源如果不尽快释放的话，可能影响到操作系统内核的其它管理工作，因此在访问内核程序临界区期间不能进行调度与切换

普通程序临界资源（如打印机）的访问是可以被打断的，可以进行进程切换，防止CPU一直空闲

#### 2.2.2 切换与过程

狭义的进程调度与进程切换的区别：

狭义的进程调度是指从就绪队列中选中一个要运行的进程（可能是刚刚被暂停的进程，也可能是另一个进程，后一种情况就需要进程切换）

进程切换是指一个进程让出处理器，由另一个进程占用处理器的过程

广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来的运行进程各种数据的保存

2. 对新的进程各种数据的恢复

    （如程序计数器、程序状态字、各种数据寄存器等处理器现场信息，一般保存在PCB）

进程切换是有代价的，过于频繁会导则系统效率降低

#### 2.2.3 方式

##### 2.2.3.1 非剥夺调度方式（非抢占方式）

只允许进程主动放弃处理器，在运行过程中即时有更紧迫的任务到达，当前进程依然会继续使用处理器，直到该进程终止或主动要求进入阻塞态。

实现简单，系统开销小，无法及时处理紧急任务，适合早期的批处理

##### 2.2.3.2 剥夺调度方式（抢占方式）

当一个进程正在处理器上执行时，如果有一个更重要或更紧迫的进程需要使用处理器，则立即暂停正在执行的进程，将处理器分配给更重要紧迫的那个进程。

可以优先处理更加紧急的进程，也可实现让各进程按照时间片轮流执行的方式（时钟中断），适合分时操作系统、实时操作系统

### 2.3 调度算法的评价指标

#### 2.3.1 CPU利用率

CPU忙碌时间占总时间的比例
$$
利用率=\frac{忙碌的时间}{总时间}
$$

#### 2.3.2 系统吞吐量

希望使用尽可能少的时间完成尽可能多的作业

系统吞吐量：即单位时间内完成作业的数量
$$
系统吞吐量=\frac{总共完成多少作业}{总共花了多少时间}
$$

#### 2.3.3 周转时间

指的是从作业被提交给系统开始，到作业完成为止这段时间间隔

包括四部分：作业在外存后备队列上等待作业调度（高级调度）的时间，进程在就绪队列上等待进程调度（低级调度）的时间（就绪态），进程在CPU上执行的时间（运行态），进程等待I/O操作完成的时间（阻塞态）。后三项在一个作业的处理过程中，可能发生多次。

$$
周转时间=作业完成时间-作业提交时间
$$

$$
平均周转时间=\frac{各作业周转时间之和}{作业数}
$$

$$
带权周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交时间}{作业实际运行时间}
$$

带权周转时间必然>=1
$$
平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}
$$

#### 2.3.4 等待时间

指进程/作业等待处理器状态时间之和，等待时间越长，用户满意度越低

对于进程来说，等待时间是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程正在被I/O设备服务，不计入等待时间

对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中的等待时间

调度算法只会影响作业/进程的等待时间

#### 2.3.5 响应时间

指的是用户提交请求到首次产生相应所用的时间

### 2.4 FCFS，SJF，HRRN调度算法

#### 2.4.1 FCFS算法

先来先服务算法，主要从公平考虑

按照作业/进程到达的先后顺序进行服务

用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列

非抢占式算法

优点：公平，算法简单

缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。该算法对长作业有利，对短作业不利

该算法不会导致饥饿

#### 2.4.2 SJF算法

短作业优先，追求最少的平均等待时间，最少的平均周转时间，最少的带权平均周转时间

最短的作业/进程优先得到服务，要求服务时间最短

可用于作业调度，也可用于进程调度，用于进程调度时称为SPF（短进程优先算法）

SJF和SPF是**非抢占式算法**，也有抢占式版本——最短剩余时间优先算法（SRTN）

默认为非抢占式

在所有进程同时可运行或所有进程几乎同时到达时，SJF的平均等待时间、平均周转时间最少

抢占式的短作业/进程优先算法（SRTN）的平均等待时间、平均周转时间最少

优点：“最短”平均等待时间，平均等待时间

缺点：不公平，对短作业有利，对长作业不利，可能产生饥饿现象

会导致饥饿，如果有源源不断的短作业/进程到来，可能会使长作业/进程长时间得不到服务，产生饥饿，如果一直得不到服务，称为饿死

#### 2.4.3 HRRN算法

要综合考虑作业/进程的等待时间和要求服务的时间

在每次调度之前先计算各个作业/进程的相应比，选择相应比最高的作业/进程为其服务
$$
相应比=\frac{等待时间+要求服务时间}{要求服务时间}
$$
非抢占式算法

综合考虑了等待时间和运行时间，等待时间相同时，要求服务时间短的优先，要求服务时间相同时，等待时间长的优先

不会导致饥饿

### 2.5 调度算法：时间片轮转，优先级调度，多级反馈队列

#### 2.5.1 时间片轮转（RR）

公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到相应

按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未再一个时间片内执行完，则会剥夺处理器，将进程放到就绪队列队尾重新排队

主要用于进程调度

可抢占，会被强制剥夺处理器，由时钟发出时钟中断

优点：公平，响应快，适用于分时操作系统

缺点：由于高频率的进程切换，有一定开销，无法区分任务的紧急程度

不会导致饥饿

#### 2.5.2 优先级调度

越来越多的应用场景需要根据任务的紧急程度来决定处理顺序

为每个进程/作业设置一个优先级，调度时选择优先级最高的作业/进程

抢占式与非抢占式都有，抢占式需要在就绪队列发生变化时，检查是否需要抢占

就绪队列未必只有一个，可以按照不同的优先级来组织

根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种

优先级原则：

1. 系统进程的优先级高于用户进程

2. 前台进程的优先级高于后台进程
3. 操作系统偏好I/O型进程（或称I/O繁忙型进程）

如果进程在就绪队列中等待太长时间，可以适当提升其优先级

如果某进程占用处理器太长时间，可以适当降低其优先级

如果一个进程频繁进行I/O操作，可以适当提升其优先级

优先：使用优先级区分紧急程度、重要程度，适用于实时操作系统，可灵活地调整各种作业/进程的偏好程度

缺点：若源源不断有高优先级进程到来，则可能导致饥饿

会发生饥饿

#### 2.5.3 多级反馈队列

是一种对其他调度算法的折中权衡

规则：

1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
2. 新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾，如果此时已经是在最下级的队列，则重新放回该队列队尾
3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片

该算法主要用于进程调度

该算法是一种可抢占式算法，在k级队列的进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理器，原来运行的进程放回k级队列队尾

优点：各类进程相对公平（FCFS），每个新到达的进程很快就可以得到相应（RR），短进程只用较少的时间就可以完成（SPF），不必实现估计进程的运行时间，可灵活调整对各类进程的偏好程度（如CPU密集，I/O密集）

可能会导致饥饿

## 3 进程同步

### 3.1 进程同步、进程互斥

#### 3.1.1 进程同步

进程具有异步性，各并发的进程以各自独立的、不可预知的速度向前推进

同步机制用于对进程的顺序进行管理

同步亦称为直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程需要在某些位置上协调它们的工作次序而产生制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

#### 3.1.2 进程互斥

进程并发需要共享的支持，各个并发执行的进程不可避免的需要共享一些资源

对临界资源的访问，逻辑上可以分为如下四个部分

```c
do {
    entry section;		// 进入区
    critical section;	// 临界区
    exit section;		// 退出区
    remainder section;	// 剩余区
} while(true)
```

进入区：检查临界资源是否可访问，若可进入，则应设置正在访问临界资源的标志（上锁），以阻止其他进程进入临界区

临界区（临界段）：实际访问临界资源的代码

退出区：负责解除正在访问临界资源标志

剩余区：做其他处理

进入区和退出区是负责实现互斥的代码段

为了实现对临界资源的互斥发那个我呢，同时保证系统整体性能，需要遵循以下原则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. 优先等待。对请求访问的进程，应保证在有限时间内进入临界区而不发生饥饿
4. 让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待

### 3.2 进程互斥的软件实现方法

#### 3.2.1 单标志法

一个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予

#### 3.2.2 双标志先检查

设置一个boolean数组flag[]，数组中的元素用来标记各进程是否想进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志设为true，之后开始访问临界区

该方法的主要问题在于，违背了忙则等待原则，可能会导致同时访问，原因是进入区的检查操作和上锁操作不是原子操作

#### 3.2.3 双标志后检查

先上锁后检查，以防止同时占用

可能会违背空闲让进和有限等待原则，可能会导致多个进程都无法访问空闲的临界资源，导致饥饿

#### 3.2.4 Peterson算法

结合双标志法、单标志法的思想，如果双方都想进入临界区，尝试谦让

flag数组表达意愿，turn标志位表示优先让哪个进程进入临界区

首先表达意愿，然后设置对方优先，之后开始循环检查

谁最后谦让，谁就失去了行动的优先权

该算法的缺点是未遵循让权等待

### 3.3 进程互斥的硬件实现方法



